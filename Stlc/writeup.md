Our primary project was an attempt to prove strong normalization for the simply typed lambda calculus in Coq. We used the Metalib library for definitions of the STLC. We began by attempting to adapt Girard's proof of strong normalization [TODO cite]. However, Girard's proof requires that all types in STLC be inhabited, and relies on a not-strictly-positive definition of "reducibility", which made it difficult to adapt. We realized that it was actually much stronger than necessary for our purposes, as the Metalib implementation of STLC is deterministic. As a result, we could simply prove weak normalization, after which strong normalization would follow easily.

Weak normalization also proved very difficult to adapt. Girard's proof depended on each term having a *degree*, whose definition ultimately depended on the types in redexes within the term. Specifically, the degree of a redex `(lam x.t) u` was depended on the type of `lam x.t`. Unfortunately for us, Metalib's STLC does not annotate the bound variable type on lambda abstractions, meaning that expressions can have an infinite number of potential types. For instance, `(lam x.x) (lam y.y)` can be represented as `(app (abs (var_b 0)) (abs (var_b 0)))` (where `app` denotes application, `abs` lambda abstraction, and `var_b` a bound variable with a De Brujin index), and the degree of this redex would depend on the type `(U->U)->U->U` - for any possible `U`. As a result, a term could not simply have a fixed degree - it could have an infinite number of degrees depending on how the types of the redexes were interpreted. This made it impossible to reason about degree decreasing as steps were taken.

We attempted to solve this problem by defining degree for a term based on a particular type within a particular context. By making explicit the types used in defining the degrees of the redexes, we hoped to solidify the interpretation of what type a term was, therefore ensuring that degree (under that interpretation) would always go down upon taking a step.

This ran into further difficulties with Metalib's specification of STLC. Under Metalib's typing relation, bound variables cannot have types. If the body of a lambda contained the variable bound at that lambda, the type (and thus degree) of the body (and thus of the lambda) could not be ascertained without substituting in a free variable for the bound variable. 
