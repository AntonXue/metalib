Our primary project was an attempt to prove some theorems about the STLC in Coq, including Church Rosser, strong normalization and propertites of Church numerals. We used the Metalib library for definitions of the STLC. We began by attempting to adapt Girard's proof of strong normalization [TODO cite]. However, Girard's proof requires that all types in STLC be inhabited, and relies on a not-strictly-positive definition of "reducibility", which made it difficult to adapt. We realized that it was actually much stronger than necessary for our purposes, as the Metalib implementation of STLC is deterministic. As a result, we could simply prove weak normalization, after which strong normalization would follow easily.

Weak normalization also proved very difficult to adapt. Girard's proof depended on each term having a *degree*, whose definition ultimately depended on the types in redexes within the term. Specifically, the degree of a redex `(lam x.t) u` depended on the type of `lam x.t`, and the degree of a term was the greatest redex degree of its redexes. (Note: redex degree and term degree are not the same; a redex term has a separate redex degree and term degree.) Unfortunately for us, Metalib's STLC does not annotate the bound variable type on lambda abstractions, meaning that expressions can have an infinite number of potential types. For instance, `(lam x.x) (lam y.y)` can be represented as `(app (abs (var_b 0)) (abs (var_b 0)))` (where `app` denotes application, `abs` lambda abstraction, and `var_b` a bound variable with a De Brujin index), and the degree of this redex would depend on the type `(U->U)->U->U` - for any possible `U`. As a result, a term could not simply have a fixed degree - it could have an infinite number of degrees depending on how the types of the redexes were interpreted. This made it impossible to reason about degree decreasing as steps were taken.

We attempted to solve this problem by defining an inductive relation `degree_term` based on a particular type within a particular context. By making explicit the types used in defining the degrees of the redexes, we hoped to solidify the interpretation of what type a term was, therefore ensuring that degree (under that interpretation) would always go down upon taking a step. We tried two approaches for determining which type to fix for the degree of a term. In the first approach, we used the type of the term. This failed because the type of an application was the type of the result of applying a function to an input, and thus insufficient to determine the type of the function being applied. 

In the second, somewhat more successful approach, we let the fixed type of an application be the type of the function being applied, and otherwise had the fixed type be the type of the term. This had the benefit of ensuring that the type fixed for the term degree of a redex term was the same type used to determine the redex degree of that expression. However, it required some tricky work to ensure that the proper type was passed down to subexpressions. We ended up solving this by producing a function `tm_deg_type` which took an expression and a type, and produced the proper type to fix for the term degree of that expression.

This approach ran into further difficulties with Metalib's specification of STLC. Under Metalib's typing relation, bound variables cannot have types. If the body of a lambda contained the variable bound at that lambda, the type (and thus degree) of the body (and thus of the lambda) could not be ascertained without substituting in a free variable for the bound variable and modifying the context. To do this, we needed to ensure we had a fresh variable, which was initially difficult (due to troubles with Coq imports), but in the end we were able to solve the problem of creating a fresh variable.

Unfortunately, we ran into a deeper error which we were unable to solve. The rule for typing of abstractions requires that the substituted variable not be in an arbitrary set of variables $L$, for ease of certain foundational proofs. Despite the `pick fresh` tactic, we could not escape it in our inductive definition of `degree_term`. Without access to the arbitrary set used in constructing the typing of a term, we could not guarantee that the variable we substituted in was fresh with regards to that set.

Church Rosser theorem is trivial to prove in this conception of STLC because each step is deterministic. We attempted a proof of Church Rosser in an STLC that contained additional stepping sematics but it currently has holes in it, largely due to subsituting in abstractions. The current abstractions are all defined using bounded variables, which can have some issues when abstractions are subsituted into other abstractions. 

Chruch numerals were easy to define, but unfortuntally, we needed to defined an extended stepping sematic in order to verify the successor, app and multi functions. One interesting property of proving theorems about church numerals is how induction proceeded. In particular, if the statement was church n -->* b, it was very difficult to apply induction on n. What we ended up doing was defining a way to step to opening operations, and then proving statements about the opening useing induction. Then we could rewrite the steps to achieve the desired result. 
