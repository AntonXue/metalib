%% This file uses the Ott tool to specify the grammar, typing and
%% evaluation rules for the call-by-value lambda calculus

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar var, x, y ::=
  {{ repr-locally-nameless }}
  {{ com variables }}
  {{ lex alphanum }}

indexvar index, i ::=
  {{ coq nat }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR (LNgen portion)

grammar

typ, T :: 'typ_' ::= {{ com types }}
  | base        ::   :: base
    {{ tex \mathsf{o} }}
  | T1 -> T2    ::   :: arrow

exp, e, v :: ''     ::= {{ com expressions }}
  | x              ::   :: var
  | \ x . e        ::   :: abs
    (+ bind x in e +)
	 {{ tex [[\]][[x]].[[e]] }}
  | e1 e2          ::   :: app
  | e1 [ x ~> e2 ] :: M :: subst
     {{ coq (open_exp_wrt_exp [[x e1]][[e2]]) }}
  | ( e )          :: S :: paren
     {{ coq ([[e]]) }}

substitutions
  single exp x   :: subst


freevars
  exp x      :: fv

parsing
  typ_arrow right typ_arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR  (non LNgen portion)

grammar

ctx, G {{ tex \Gamma }} :: ''     ::= {{ com typing context }} {{ coq list ( atom * typ ) }}
  | empty          ::   :: Empty {{ coq nil }}
  | G , x : T      ::   :: Cons  {{ coq (([[x]]~[[T]])++[[G]]) }}


terminals :: 'terminals_' ::=
    | \                   ::   :: lambda     {{ tex \lambda }}
    | -->                 ::   :: red        {{ tex \longrightarrow }}
    | ==>                 ::   :: bigred     {{ tex \Longrightarrow }}
    |  ->                 ::   :: arrow      {{ tex \rightarrow }}
    | |-                  ::   :: turnstile  {{ tex \vdash }}
    | in                  ::   :: in         {{ tex \in }}
    | fv                  ::   :: fv         {{ tex \mathsf{fv}\! }}
    | ~>                  ::   :: leadsto    {{ tex \leadsto }}


formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | is_value v               ::   :: is_value
    {{ coq is_value [[v]] }}
  | uniq G                   ::   :: uniqG
    {{ coq uniq [[G]] }}
  | x : T in G               ::   :: inG
    {{ coq binds [[x]][[T]][[G]] }}
  | x notin fv e             ::   :: fresh
    {{ coq [[x]] \notin fv[[e]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}



embed
{{ coq

Definition is_value (e : exp) : Prop :=
  match e with
  | abs _   => True
  | _       => False
  end.

Module StlcNotations.
Notation "[ z ~> u ] e" := (subst_exp u z e) (at level 68).
Notation open e1 e2     := (open_exp_wrt_exp e1 e2).
End StlcNotations.
}}

defns

JTyping :: '' ::=

defn
G |- e : T ::   :: typing :: 'typing_'
by

uniq G
x : T in G
------------ :: var
G |- x : T


G, x:T1 |- e : T2
-------------------------- :: abs
G |- \x. e : T1 -> T2


G |- e1 : T1 -> T2
G |- e2 : T1
------------------ :: app
G |- e1 e2 : T2

defns

JEval :: '' ::=

defn
e --> e' ::   :: step :: 'step_'
by

------------------------------- :: beta
(\x.e1) v --> e1 [x ~> v]

e1 --> e1'
----------------- :: app
e1 e2 --> e1' e2

defns

JBig :: '' ::=

defn
e ==> v  ::  :: bigstep :: 'bs_'
by

e1 ==> \x.e1'
e2 ==> v1
e1' [ x ~> v1 ] ==> v2
---------------------- :: app
e1 e1 ==> v2

----------------- :: val
v ==> v


defns

Jeq :: '' ::=

defn
e = e' ::  :: eq :: 'eq_'  by


------ :: refl
e = e

e1 = e2
--------- :: sym
e2 = e1

e1 = e2
e2 = e3
--------- :: trans
e1 = e3

--------------------- :: beta
(\x.e) e1 = e [x ~> e1]


e1 = e2
------------- :: abs_cong
\x.e1 = \x.e2


e1 = e1'
e2 = e2'
--------------- :: app_cong
e1 e1' = e2 e2'