%% This file uses the Ott tool to specify the grammar, typing and
%% evaluation rules for STLC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar var, x, y ::=
  {{ repr-locally-nameless }}
  {{ com variables }}
  {{ lex alphanum }}

indexvar index, i ::=
  {{ coq nat }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR (LNgen portion)

grammar

typ, T :: 'typ_' ::= {{ com types }}
  | base        ::   :: base
  | T1 -> T2    ::   :: arrow

exp, e :: ''     ::= {{ com expressions }}
  | x              ::   :: var
  | \ x : T . e    ::   :: abs
    (+ bind x in e +)
	 {{ tex [[\]][[x]]\!:\![[T]].[[e]] }}
  | e1 e2          ::   :: app
  | e1 [ x ~> e2 ] :: M :: subst
     {{ coq (open_exp_wrt_exp [[x e1]][[e2]]) }}
  | ( e )          :: M :: paren
     {{ coq ([[e]]) }}


substitutions
  single exp x :: subst

freevars
  exp x        :: fv

parsing
  typ_arrow right typ_arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR  (non LNgen portion)

grammar


ctx, G {{ tex \Gamma }} :: ''     ::= {{ com typing context }} {{ coq list ( atom * typ ) }}
  | empty          ::   :: Empty {{ coq nil }}
  | G , x : T      ::   :: Cons  {{ coq (([[x]]~[[T]])++[[G]]) }}

value, v :: 'v_' ::= {{ com values }}
  | \ x : T . e   ::        :: abs
    (+ bind x in e +)
	 {{ tex [[\]][[x]]\!:\![[T]].[[e]] }}

terminals :: 'terminals_' ::=
    | \                   ::   :: lambda     {{ tex \lambda }}
    | -->                 ::   :: red        {{ tex \longrightarrow }}
    | ==>                 ::   :: bigred     {{ tex \Longrightarrow }}
    |  ->                 ::   :: arrow      {{ tex \rightarrow }}
    | |-                  ::   :: turnstile  {{ tex \vdash }}
    | in                  ::   :: in         {{ tex \in }}
    | fv                  ::   :: fv         {{ tex \mathsf{fv}\! }}
    | ~>                  ::   :: leadsto    {{ tex \leadsto }}


formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | uniq G                   ::   :: uniqG
    {{ coq uniq [[G]] }}
  | x : T in G               ::   :: inG
    {{ coq binds [[x]][[T]][[G]] }}
  | x notin fv e             ::   :: fresh
    {{ coq [[x]] \notin fv[[e]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}

subrules

v <:: e


embed
{{ coq

Notation "[ z ~> u ] e" := (subst_exp u z e) (at level 68).
Notation "e1 ^ x"       := (open_exp_wrt_exp e1 (var_f x)).
}}

defns

JTyping :: '' ::=

defn
G |- e : T ::   :: typing :: 'typing_'
by

uniq G
x : T in G
------------ :: var
G |- x : T


G, x:T1 |- e : T2
-------------------------- :: abs
G |- \x:T1. e : T1 -> T2


G |- e1 : T1 -> T2
G |- e2 : T1
------------------ :: app
G |- e1 e2 : T2

defns

JEval :: '' ::=

defn
e --> e' ::   :: step :: 'step_'
by

------------------------------- :: beta
(\x:T1.e1) v --> e1 [x ~> v]

e1 --> e1'
----------------- :: app1
e1 e2 --> e1' e2

e2 --> e2'
----------------- :: app2
v e2 --> v e2'

defns

JBig :: '' ::=

defn
e ==> v  ::  :: bigstep :: 'bs_'
by

e1 ==> \x:T1.e1'
e2 ==> v1
e1' [ x ~> v1 ] ==> v2
---------------------- :: app
e1 e1 ==> v2

----------------- :: val
v ==> v
